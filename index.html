<!DOCTYPE html>
<html>

	<head>
		<title>Slides</title>
		<link rel="stylesheet" href="./multiCol.css">
		<link rel="stylesheet" href="./Reveal/reveal.css">
		<!-- <link rel="stylesheet" href="./Reveal/theme/black.css"> -->
		<link rel="stylesheet" href="./Reveal/theme/beige.css">
	</head>

	<body>
		<div id="stats"></div>
		<div class="reveal">
			<div class="slides" id="slides">
				<section id="Title" data-visibility="uncounted"> 
					<h3 class='r-fit-text'>Hexahedral  Mesh  Generation</h3>
					<h3 class='r-fit-text'>For Tubular Shapes Using Skeletons and Connection Surfaces</h3>
					<div class="r-hstack" style="font-size: 0.5em; padding-top:2.7em;">
						<div style="padding-right:10%" ><a href="https://igg.icube.unistra.fr/en/index.php/People">P. Viville</a></div>
						<div style="padding-right:10%"><a href="https://igg.icube.unistra.fr/en/index.php/People">P. Kraemer</a></div>
						<div ><a href="https://igg.icube.unistra.fr/en/index.php/Dominique_Bechmann">D. Bechmann</a></div>
					</div>
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<img src="Images/Title/IGG.png" height="40px" style="padding-right: 5%;">
						<img src="Images/Title/ICube.png" height="40px" style="padding-right: 5%;">
						<img src="Images/Title/CNRS.png" height="40px" style="padding-right: 5%;">
						<img src="Images/Title/unistra.png" height="40px" >
					</div>

					<aside class="notes">
						Thank you for giving me the opportunity to present my work.
						<br /><br />
						I will present the work I have done during the first year of my PhD under the supervision of Pierre Kraemer and Dominique Bechmann.
						<br /><br />
						This work is on the topic of hexahedral mesh generation for tubular shapes using skeletons and connection surfaces.
						These slides contain interactive 3D images of our results, feel free to take a look for yourself during the presentation.
						üñ±Ô∏è 
						<br /><br />
						( üñ±Ô∏è = next )
					</aside>
				</section>

				<section id="Overview"> 
					Overview
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack"> 
						<div>
							<canvas id="overview_input" width="350" height="400"></canvas>
							<p style="font-size:20px; margin-top: 0px;">Input</p>
						</div>
						<img src="Images/Utils/arrow.png" height="80px" style="padding-right: 1%; padding-left: 1%;">
						<div>
							<canvas id="overview_output" width="350" height="400"></canvas>
							<p style="font-size:20px; margin-top: 0px;">Output</p>
						</div>
					</div>
					<div class="fragment" id="Overview_clipping"></div>
					<!-- <div class="fragment" id="Overview_pause"></div> -->
					<aside class="notes">
						To give a brief overview: the purpose of our work is to start with a surface mesh,
						for instance one extracted from medical imaging, from which a curve skeleton
						can be extracted, and from these: produce a fully hexahedral mesh to be used as
						a support for physical simulation. üñ±Ô∏è
						<br /><br />
						A hexahedral mesh being a mesh composed exclusively of cells that are
						hexahedron, in other words: deformed cubes.üñ±Ô∏è
					</aside>
				</section>

				<section id="Introduction_0"> 
					Hex Meshes
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<div>
							<img src="Images/Utils/hexmesh.PNG" height="300px" >
							<p style="font-size:20px; margin-top: 0px;"><a hreflang="https://www.hexalab.net/">Hexalab</a></p>
						</div>
						<ul style="font-size: 25px;">
							<li style="padding-top: 14px;">Highly Sought After</li>
							<li style="padding-top: 14px;">Superior Numerical Properties</li>
							<li style="padding-top: 14px;">Notoriously Difficult to Produce</li>
						</ul>
					</div>

					<aside class="notes">
						Hexahedral meshes are very interesting for applications of physical simulation.
						Some simulation codes can be up to fifty times faster than with mixed or tetrahedral meshes.
						Hexahedrons also allegedly have superior numerical properties for finite element methods.
						But it is also notoriously difficult to produce high quality hexahedral meshes. üñ±Ô∏è
						<br /><br />
					</aside>
				</section>

				<section id="Existing Work"> 
					Prior Works
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">  
						<div class="r-vstack">  
							<div class="r-hstack">
								<div>  
									<img src="Images/Existing/existing0.PNG" height="220px" style="padding-right: 10%; margin: 0px;">
									<p style="font-size:12px; margin-top: 0px;"><a href="http://www.cs.ubc.ca/labs/imager/tr/2013/polycut/downloads/polycut.pdf">(Livesu, ACM 2013)</a></p>
								</div>
								<div>  
									<img src="Images/Existing/existing2.PNG" height="220px" style="padding-right: 0%; margin: 0px;">
									<p style="font-size:12px; margin-top: 0px;"><a href="http://pers.ge.imati.cnr.it/livesu/papers/LMPS16/LMPS16.pdf">(Livesu, CGF 2016)</a></p>
								</div>
							</div>
							<div class="r-hstack">
								<div>  
									<img src="Images/Existing/existing1.PNG" height="200px" style="padding-right: 10%; margin: 0px;">
									<p style="font-size:12px; margin-top: 0px;"><a href="https://gaoxifeng.github.io/papers/2019/2019-OctreeMeshing.pdf">(Gao, SGP 2019)</a></p>
								</div>
								<div>  
									<img src="Images/Existing/existing3.PNG" height="200px" style="padding-right: 0%; margin: 0px;">
									<p style="font-size:12px; margin-top: 0px;"><a href="http://research.nii.ac.jp/~takayama/dual-sheet-meshing/dual-sheet-meshing-eg2019.pdf">(Takayama, CGF 2019)</a></p>
								</div>
							</div>
						</div>
						<div>
							<ul style="font-size: 22px;">
								<li style="padding-top: 14px;">No Reliable Generic Method</li>
								<li style="padding-top: 14px;">Few Guarantees on Topology and Quality</li>
								<li style="padding-top: 14px;">Heavy User Input</li>
								<li style="padding-top: 14px;">Many Specialized Methods</li>
								<!-- <li style="padding-top: 14px;"></li> -->
							</ul>
						</div>
					</div>
					<aside class="notes">
						Over time, a large number of methods to produce hexahedral meshes have been proposed.
						Of those, very few are generic methods that can apply to any type of geometric domain reliably.
						On the top left you have an example of the polycubes method by Livesu & al, and on the bottom left an octree-based subdivision
						by Gao & al.
						Most methods do not provide any guarantees on the topology or the quality of the mesh.
						Some of those methods also require heavy user input to partition the initial domain in patches or verify
						properties. One such method is shown with the Bunny by Takayama & al.
						<br /><br />
						There are also a large number of methods that apply to special cases of geometric domains, including
						one applied to tubular meshes that can be represented by skeletons, by Livesu & al, shown in the blue warrior.
						But this method in our opinion presented a few undesirable properties, such as having to solve a global
						optimization problem to create the initial mesh, arbitrary choices of topology when dealing with cycles, and 
						as you can see on the warrior's hips: asymetrical results on a symetrical domain. üñ±Ô∏è
					</aside>
				</section>
		
				<section id="Pipeline_simple"> 
					Pipeline
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<div style="padding-right:2%;">  
							<canvas  id="Pipeline00_surface" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Input<br>Surface</p>
						</div>
						<div class="fragment" style="padding-right:2%">  
							<canvas id="Pipeline00_skel" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Processed<br>Skeleton</p>
						</div>
						<div class="fragment">  
							<canvas id="Pipeline00_scaffold" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Skeleton<br>Scaffold</p>
						</div>
						<div class="fragment" style="padding-right:2%">  
							<canvas id="Pipeline00_mesh" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Output<br>Mesh</p>
						</div>
					</div>
					<aside class="notes">
						One of the main challenges in generating a hexahedral mesh of a tubular geometry such as this cactus is handling the branching
						points, and a second one is to obtain a properly structured mesh aligned with the border of the domain.üñ±Ô∏è

						Inspired by prior works such as Livesu & al's, and Panatopoulou & al's, we came up with a method that makes use of the 
						skeleton representation of the geometric domain to build our mesh.	üñ±Ô∏è

						We leverage what we call connection surfaces, quadrilateral partitions of spheres, used as scaffolds, to determine
						the connectivity of the hexahedral mesh locally to each vertex of the skeleton üñ±Ô∏è

						For that purpose we have develloped a new method to partition a sphere into N quads, along with the entire pipeline from surface to hex meshüñ±Ô∏è
					</aside>
				</section>

				<section id="Connection_Surfaces"> 
					Connection Surfaces
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<img src="Images/Path_Co/spheres.png" height="300px">
					<!-- <p style="font-size:30px; margin-top: 0px;">Quad Scaffolding Based on Vertex Degree</p> -->
					<aside class="notes">
						The connection surfaces are built localy on each vertex, depending on it's degree, without any need for a larger context.
						<br /><br />
						You can see here how we handle a vertex of degree 1, an extremity, with a single quad. A vertex of degree 2,
						a joint, with a sphere partitioned in 2 quads, and a vertex of degree 4, a complex branching point.
						For joints and extremities, the vertices of the connection surfaces are set on the plane
						orthogonal to the branch's tangent. The geometry is propagated from the more constrained complex branching points through 
						rotation minimizing frames. üñ±Ô∏è
					</aside>
				</section>

				<section id="Hexahedra Generation"> 
					Hexahedra Generation
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<img src="Images/Path_Co/chunk.png" height="300px">
					<p style="font-size:30px; margin-top: 0px;">Insertion of 4 Hex Chunk per Edge</p>
					<aside class="notes">
						On each edge of the skeleton, a chunk composed of 4 hexahedra is added.
						It is then linked to the corresponding quads of incident vertices' connection surfaces.
						<br /><br />
						Having a chunk made of 4 hex associated to the quads of the connection surfaces will
						allow us to handle any branching point generically. üñ±Ô∏è
					</aside>
				</section>

				<section id="Connectivity"> 
					Connectivity
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-vstack">  
						<div class="r-hstack">
							<img src="Images/Path_Co/stitching_0.png" height="170px">
							<img class="fragment" src="Images/Path_Co/stitching_1.png" height="170px">
							<img class="fragment" src="Images/Path_Co/stitching_2.png" height="170px">
						</div>
						<div class="r-hstack">
							<img class="fragment" src="Images/Path_Co/stitching_3.png" height="170px">
							<img class="fragment" src="Images/Path_Co/stitching_4.png" height="170px">
							<img class="fragment" src="Images/Path_Co/stitching_5.png" height="170px">
						</div>
					</div>
					<aside class="notes">
						In order to explain how connectivity of the mesh is handled with these connection 
						surfaces, I will run you through a simple example of a branching point with 3 branches. üñ±Ô∏è
						<br /><br />
						First of all a connection surface composed of 3 quads is added to the vertex,
						each branch being associated to a quad. üñ±Ô∏è
						<br /><br />
						Subsequently, as chunks are added to incident edges, they are associated to the connection
						surface. Each hexahedron of the chunk is linked to the corresponding edge of a quad. üñ±Ô∏è
						<br /><br />
						This results in each edge of the connection surface being linked to 2 hexes üñ±Ô∏è. Allowing us to
						easily retrieve the pairs and stiching them together. üñ±Ô∏è
						<br /><br />
						This method is generalizable to intersections of any degree as long as each edge is surrounded
						by 2 quads.
						It is fairly easy to parallelize especially with a half edge structure.
						<br /><br />
						I will now give a bit more detail on how these connection surfaces are obtained. üñ±Ô∏è
					</aside>
				</section>

				<section id="Sphere_Partition"> 
					Complex Branching Points
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-vstack">  
						<div class="r-hstack">
							<div style="padding-right:2%">  
								<canvas id="SP_init" width="200" height="166" ></canvas>
								<p style="font-size:18px; margin-top: 0px;">Branching<br>Point</p>
							</div>
							<div class="fragment" style="padding-right:2%">  
								<canvas id="SP_Points" width="200" height="166" ></canvas>
								<p style="font-size:18px; margin-top: 0px;">Branching<br>Point</p>
							</div>
							<div class="fragment" style="padding-right:2%">  
								<canvas id="SP_Raw" width="200" height="166"></canvas>
								<p style="font-size:18px; margin-top: 0px;">Delaunay<br>Triangulation</p>
							</div>
							
						</div>
						<div class="r-hstack">
							<div class="fragment">  
								<canvas id="SP_Remesh" width="200" height="166"></canvas>
								<p style="font-size:18px; margin-top: 0px;">Vertices Degree 4<br>Remeshed</p>
							</div>
							<div class="fragment" style="padding-right:2%">  
								<canvas id="SP_Dual" width="200" height="166"></canvas>
								<p style="font-size:18px; margin-top: 0px;">Dual<br>Construction</p>
							</div>
							<div class="fragment">  
								<canvas id="SP_Result" width="200" height="166"></canvas>
								<p style="font-size:18px; margin-top: 0px;">Resulting<br>Partition</p>
							</div>
						</div>
					</div>
					<aside class="notes">
						To create the connection surfaces we develloped a generic method and use two other methods 
						for special cases. I will start by explaining the process of the generic method.
						Our goal is to obtain a partition of the sphere made of as many quads as there are branches in the branching point, 
						with each quad being as convex as possible and containing it's own branch.

						<br /><br />
						The first step is creating a sphere centered on the vertex, and intersecting the branches with
						the sphere to obtain a set of points on it's surface. üñ±Ô∏è
					
						<br /><br />
						Generating the desired quad mesh from this unstructured set of points is problematic,
						prompting us to reverse the process. The dual of a mesh composed of N quads is a mesh composed of N vertices
						of degree 4. 
						We therefor start by constructing the dual mesh of our desired partition.
						To that goal the Delaunay triangulation of these points is created as a base mesh, as seen in blue. üñ±Ô∏è
						<br /><br />
						The Delaunay triangulation is then modifyed without removing or adding any vertex to obtain a mesh with only vertices of degree 4, seen in green.
						The euristic we have used for the remeshing step uses an angle criterion to prioritize the deletion
						and insertion of edges that modify the connectivity.
						It might not be ideal and other methods resulting in the vertices of degree 4 only could be used. üñ±Ô∏è
						<br /><br />
						Once the remeshing is done, to obtain the partition we simply dualize the mesh, with each vertex of the dual being placed on the 
						corresponding face's barycenter,
						and obtain the final partition as seen in orange. üñ±Ô∏è
						<br /><br />
						The choice of using the Delaunay triangulation as a base mesh was reasoned by trying to 
						obtain a final partition as close as possible to the Voronoi diagram of the set of points on
						the sphere, which would have the ideal properties of convex quads each containing their 
						point. In some specific cases our partition will be the Voronoi Diagram üñ±Ô∏è

					</aside>
				</section>

				<section id="Results_Partition"> 
					Sphere Partitions
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<div style="padding-right:2%">  
							<canvas id="Partition14" width="340" height="340" ></canvas>
							<p style="font-size:20px; margin-top: 0px;">14 Points<br>Success</p>
						</div>
						<div class="fragment">  
							<canvas id="Partition_failure" width="340" height="340"></canvas>
							<p style="font-size:20px; margin-top: 0px;">5 Points<br>Failure</p>
						</div>
					</div>
					<aside class="notes">
						Our current remeshing method works well even on branching points of high degrees
						as long as the repartition of the points on the sphere is not too heterogeneous. 
						As you can see with the example on the left that has 14 points. üñ±Ô∏è
						<br /><br />
						If the repartition is too heterogeneous, the method will fail to provide a proper partition
						with a quad containing it's own point. 
						<br /><br />
						This failure can be compensated further down the line with geometric optimisation of the results
						but is likely to lower the quality of the results. üñ±Ô∏è
					</aside>
				</section>

				<section id="Flat_Partition"> 
					Flat Case
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<div style="padding-right:2%">  
							<canvas id="FP_3Points" width="200" height="166" ></canvas>
							<p style="font-size:18px; margin-top: 0px;">3 Points</p>
						</div>
						<div  style="padding-right:2%">  
							<canvas id="FP_4Points" width="200" height="166"></canvas>
							<p style="font-size:18px; margin-top: 0px;">4 Points</p>
						</div>
						<div>  
							<canvas id="FP_5Points" width="200" height="166"></canvas>
							<p style="font-size:18px; margin-top: 0px;">5 Points</p>
						</div>
					</div>
					<div class="fragment" id="Flat_base"></div>
					<div class="fragment" id="Flat_sphere"></div>
					<div class="fragment" id="Flat_surface"></div>
					
					<aside class="notes">
						In the case of flat branching points, where all points are close to the average plane üñ±Ô∏è
						a more straightforward method can be used.
						<br /><br />
						The points are projected onto the plane and sorted, 2 poles are created 
						and connected by the meridians going through the mid points of each neighboring pairs of points.
						Demonstrated here for branching points of degree 3 , 4 and 5 
					</aside>
				</section>

				<section id="Ortho_Partition"> 
					Cube Case
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<div style="padding-right:2%">  
							<canvas id="OP_3Points" width="200" height="200" ></canvas>
							<p style="font-size:18px; margin-top: 0px;">3 Points</p>
						</div>
						<div style="padding-right:2%">  
							<canvas id="OP_4Points" width="200" height="200"></canvas>
							<p style="font-size:18px; margin-top: 0px;">4 Points</p>
						</div>
						<div>  
							<canvas id="OP_5Points" width="200" height="200"></canvas>
							<p style="font-size:18px; margin-top: 0px;">5 Points</p>
						</div>
					</div>
					<div class="fragment" id="Ortho_base"></div>
					<div class="fragment" id="Ortho_surface"></div>
					<aside class="notes">
						Another special case is branching points with all branches either 
						mutually orthogonal or aligned pairwise, within a threshold angle. As in those 3 examples of degrees 3, 4, and 5.
						üñ±Ô∏è<br />
						In this case a better solution for the connection surface is the 
						insertion of a subdivided cube on the branching point, keeping incident
						branches as orthogonal as possible to the faces of the cube.<br />
						üñ±Ô∏è The subdivided cube exposes a compatible interface for incoming branches.
						<br /><br />
					</aside>
				</section>

				<section id="Ortho_Partition_3_4"> 
					Method Choice
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-vstack">  
						<img src="Images/Utils/ortho.PNG" height="300px">
						<p style="font-size:25px; margin-top: 0px;">Method Choice<br>Based on Future Quality</p>
						<!-- <div class="r-hstack">
							<div style="padding-right:2%">  
								<canvas id="Ortho3_1" width="200" height="166" ></canvas>
								<p style="font-size:18px; margin-top: 0px;">Flat</p>
							</div>
							<div>  
								<canvas id="Ortho3_2" width="200" height="166"></canvas>
								<p style="font-size:18px; margin-top: 0px;">Ortho</p>
							</div>
						</div>
						<div class="r-hstack fragment">
							<div  style="padding-right:2%">  
								<canvas id="Ortho4_1" width="200" height="166"></canvas>
								<p style="font-size:18px; margin-top: 0px;">Flat</p>
							</div>
							<div>  
								<canvas id="Ortho4_2" width="200" height="166"></canvas>
								<p style="font-size:18px; margin-top: 0px;">Ortho</p>
							</div>
						</div> -->
					</div>
					<aside class="notes">
						This cube case has some fairly obvious limitations and advantages depending on
						configurations, as you can see with these two examples.
						On the top, using the flat case results in a better result than the cube case to the right.
						On the bottom, using the cube case is more adapted.
						<br /><br />
						Different cases being mutually compatible allows our method greater versatility to 
						select automatically the best case for each skeleton vertex depending on local configuration. üñ±Ô∏è
					</aside>
				</section>

				<section id="Pipeline_0"> 
					Pipeline
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<div style="padding-right:2%;">  
							<canvas  id="Pipeline0_surface" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Input<br>Surface</p>
						</div>
						<div class="fragment" style="padding-right:2%">  
							<canvas id="Pipeline0_skel" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Extracted<br>Skeleton</p>
						</div>
						<div class="fragment">  
							<canvas id="Pipeline0_skel_simple" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Reprocessed<br>Skeleton</p>
						</div>
					</div>
					<aside class="notes">
						I will now described in broad strokes the whole pipeline from surface to 
						final hexahedral mesh.
						<br /><br />
						As stated initially, the input required is a surface mesh. üñ±Ô∏è
						<br /><br />
						From this surface mesh a skeleton curve is extracted. üñ±Ô∏è
						<br /><br />
						The skeleton is reprocessed to fit our needs.
						Alternatively, the whole process can start from the third step using a processed skeleton 
						and it's corresponding surface as an input. üñ±Ô∏è
					</aside>
				</section>

				<section id="Pipeline_1"> 
					Pipeline
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<div style="padding-right:2%;">   
							<canvas  id="Pipeline1_scaffold" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Skeleton<br>Scaffold</p>
						</div>
						<div class="fragment" style="padding-right:2%">  
							<canvas id="Pipeline1_initial_mesh" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Initial<br>Mesh</p>
						</div>
						<div class="fragment">  
							<canvas id="Pipeline1_surface_fit_mesh" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Surface fit<br>Mesh</p>
						</div>
					</div>
					<aside class="notes">
						From the skeleton, the contact surfaces can be built to set a scaffold for the initial hex mesh. üñ±Ô∏è
						<br /><br />
						From the scaffold, the initial mesh can be built by adding a chunk of 4 hexes to each edge. üñ±Ô∏è
						<br /><br />
						Subsequently, the outer vertices of the mesh can be projected to the surface. üñ±Ô∏è
						<br /><br />
					</aside>
				</section>

				<section id="Pipeline_2"> 
					Pipeline
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<div style="padding-right:2%;">   
							<canvas  id="Pipeline2_padding" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Padded<br>Mesh</p>
						</div>
						<!-- <div class="fragment" id="Pipeline2_rotate"></div>
						<div class="fragment" id="Pipeline2_rotate2"></div> -->
						<div class="fragment" style="padding-right:2%">  
							<canvas id="Pipeline2_result" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Subdivided<br>Mesh</p>
						</div>
						<div class="fragment">  
							<canvas id="Pipeline2_quality" width="220" height="360"></canvas>
							<p style="font-size: 30px;">Optimized<br>Mesh</p>
						</div>
					</div>
					<div class="fragment" id="Pipeline2_material"></div>
					<aside class="notes">
						An optional but very useful step can be applied to the mesh:
						The insertion of a padding layer. This layer as you can see is added in a manner
						to prevent any hex from exposing more than one face to the border of the domain
						This will be important for later geometric optimisation üñ±Ô∏è
						<br /><br />
						The mesh can then be subdivided üñ±Ô∏è
						<br /><br />
						And then be optimized üñ±Ô∏è 
						The method used here to optimize the mesh is Edge-Cone Rectification, using the common quality mertric:
						Scaled Jacobians to evaluate the quality. Scaled jacobians give an indication of the level of deformation
						of an hexahedron compared to a cuboid, values range from -1 to 1, the higher the better and negative values make the mesh unusable for simulation.
						The important values being the worst and average values.
						<br /><br />
						These steps of padding, subdividing, and optimization, require user input in our current setting
						, and their number and order will depend on the best judgment of said user. üñ±Ô∏è
					</aside>
				</section>

				<section id="Comparisions_Santa"> 
					Comparisons
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-vstack">  
						<div class="r-hstack">
							<div style="padding-right:2%">  
								<canvas id="Santa_live" width="340" height="340" ></canvas>
								<p style="font-size:20px; margin-top: 0px;"><a href="http://pers.ge.imati.cnr.it/livesu/papers/LMPS16/LMPS16.pdf">(Livesu, CGF 2016)</a><br>Scaled Jacobian:<br> min:0.367 - avg:0.941<br># Hex: 26240</p>
							</div>
							<div>  
								<canvas id="Santa_ours" width="340" height="340"></canvas>
								<p style="font-size:20px; margin-top: 0px;">Ours<br>Scaled Jacobian:<br> min:0.514 - avg:0.965<br># Hex: 21312</p>
							</div>
						</div>
						<div>
							Santa
						</div>
					</div>
					<div class="fragment" id="Santa_clipping"></div>
					<aside class="notes">
						This process has allowed us to produce results from input surfaces collected
						on hexalab.net.
						<br /><br />
						In this case, using the Santa mesh, we were able to obtain a result with fewer hexes, a better
						average and minimum scaled jacobian.
						The domain processed is topologically symetrical, and using our method, the hex mesh is also symetrical topologically.
						Compared to the prior work by Livesu & al were it is not.
						As can be seen on the hips of the mesh.
						üñ±Ô∏è
						Other than that, as you can see on the heat map coloring, the repartition of lower quality
						elements is in the same features with both our method and that of Livesu, but the quality is overall higher in ours. üñ±Ô∏è
					</aside>
				</section>

				<section id="Comparisions_Metatron"> 
					Comparisons
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-vstack">  
						<div class="r-hstack">
							<div style="padding-right:2%">  
								<canvas id="Meta_live" width="340" height="340" ></canvas>
								<p style="font-size:20px; margin-top: 0px;"><a href="http://pers.ge.imati.cnr.it/livesu/papers/LPPSC20/LPPSC20.pdf">(Livesu, ACM 2020)</a><br>Scaled Jacobian:<br> min:0.682 - avg:0.941<br># Hex: 4544</p>
							</div>
							<div>  
								<canvas id="Meta_ours" width="340" height="340"></canvas>
								<p style="font-size:20px; margin-top: 0px;">Ours<br>Scaled Jacobian:<br>min:0.820 - avg:0.981<br># Hex: 6624</p>
							</div>
						</div>
						<div>
							Metatron
						</div>
					</div>
					<div class="fragment" id="Metatron_clipping"></div>
					<aside class="notes">
						We also applied our method to meshes from other works, this one on block decomposition: LoopyCuts, once again by Livesu & al. üñ±Ô∏è
						<br /><br />
						As you can see, our method was able to process branching points in various ways, providing us with a much better
						minimum scaled jacobian. üñ±Ô∏è
					</aside>
				</section>

				<section id="Results_Dinopet"> 
					Results
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div style="padding-right:2%">  
						<canvas id="Result_Dinopet" width="400" height="400" ></canvas>
						<div>Dinopet</div>
						<p style="font-size:20px; margin-top: 0px;">Scaled Jacobian:<br> min:0.540 - avg:0.919</p>
					</div>
					<div class="fragment" id="Results_Dinopet_material"></div>
					<div class="fragment" id="Results_Dinopet_Clipping"></div>
					<aside class="notes">
						We applied our method to a variety of different meshes with various features.
						<br /><br />
						Here you can see it applied to the dinopet. As you can see, aside from the the beak, and the tip of the tail, the fitting
						is pretty good.
						The tip of the tale could probably be fixed with a small modificiation by hand to the skeleton.
						üñ±Ô∏è
						<br/><br/>
						üñ±Ô∏è as you can see, most elements have a good quality, üñ±Ô∏è with the worst elements being incident to the branching points.
						üñ±Ô∏è
					</aside>
				</section>

				<section id="Results_Horse"> 
					Results
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div style="padding-right:2%">  
						<canvas id="Result_Horse" width="500" height="400" ></canvas>
						<p style="font-size:20px; margin-top: 0px;">Scaled Jacobian:<br>min:0.449 - avg:0.912</p>
						<div>Horse</div>
					</div>
					<div class="fragment" id="Results_Horse_material"></div>
					<div class="fragment" id="Results_Horse_Clipping"></div>
					<aside class="notes">
						Here the method is applied to a horse.
						Once again, the fitting is pretty good aside from the sharp features of the ears.
						<br /><br />
						üñ±Ô∏è
						<br/>
						üñ±Ô∏è
						<br/>
						üñ±Ô∏è
					</aside>
				</section>

				<section id="Results_Cycles"> 
					Results
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div style="padding-right:2%">  
						<canvas id="Result_Cycles" width="500" height="400" ></canvas>
						<p style="font-size:20px; margin-top: 0px;">Scaled Jacobian:<br>min:0.316 - avg:0.937</p>
						<div>Cycles</div>
					</div>
					<div class="fragment" id="Results_Cycles_material"></div>
					<div class="fragment" id="Results_Cycles_Clipping"></div>
					<aside class="notes">
						Here the method is applied to a looping mesh, with a complex branching point at it's core.
						As you can see, the fitting to a surface well represented by curve skeleton is almost perfect.
						<br /><br />
						üñ±Ô∏è The quality along the branches is very good.
						<br/>
						üñ±Ô∏è And the core with eight branches joining in one point was handled acceptably.
						<br/>
						üñ±Ô∏è
					</aside>
				</section>

				<section id="Results_Fertility"> 
					Results
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div style="padding-right:2%">  
						<canvas id="Result_Fertility" width="500" height="380" ></canvas>
						<div>Vessels</div>
						<p style="font-size:20px; margin-top: 0px;">Scaled Jacobian:<br>min:0.543 - avg:0.933</p>
					</div>
					<div class="fragment" id="Results_Fertility_material"></div>
					<div class="fragment" id="Results_Fertility_Clipping"></div>
					<aside class="notes">
						Here is one more example.
						<br /><br />
						üñ±Ô∏èüñ±Ô∏èüñ±Ô∏è
					</aside>
				</section>

				<section id="Limitations"> 
					Limitations
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-hstack">
						<div style="padding-right:2%">  
							<canvas id="Edge_rocker" width="340" height="340"></canvas>
							<p style="font-size: 30px;">Rocker Arm</p>
							<div class="fragment" id="Edge_rocker_skel"></div>
							<div class="fragment" id="Edge_rocker_vol"></div>
							<div class="fragment" id="Edge_rocker_vol_clip"></div>
						</div>
						<div class="fragment">  
							<canvas id="Edge_mech" width="340" height="340"></canvas>
							<p style="font-size: 30px;">Mech Piece</p>
							<div class="fragment" id="Edge_mech_skel"></div>
							<div class="fragment" id="Edge_mech_vol"></div>
							<div class="fragment" id="Edge_mech_vol_clip"></div>
						</div>
					</div>
					<aside class="notes">
						Our method has limitations with objects that are not well represented by their curve skeleton.
						Such as object with elongated slices or sharp features üñ±Ô∏è
						üñ±Ô∏è in the case of the rocker arm, the elongated belly causes very deformed hexahedra to appear.
						The quality remains decent, but the elongated shape of the elements is not necessarily desirable. üñ±Ô∏è
						<br /><br />
						In the case of the mech piece though üñ±Ô∏è
						The Curve skeleton does not represent the shape well, it has a complex slice and sharp feature üñ±Ô∏è
						Causing our method to fail and output a mesh that does not capture the geometry of the domain. üñ±Ô∏è
						üñ±Ô∏è
					</aside>
				</section>

				<section> 
					Contributions
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div>
						<ul style="font-size: 25px;">
							<li style="padding-top: 0px;">Sphere N-Quad Partition Algorithm</li>
							<li style="padding-top: 14px;">Connectivity Management Using Connection Surfaces</li>
							<li style="padding-top: 14px;">Full Pipeline with Discrete Local Steps</li>	
						</ul>
					</div>
					<aside class="notes">
						The method we have presented leverages the skeletal representation of a domain to construct a high quality
						mesh whose elements are aligned with the geometry of the domain and have a mostly regular connectivity.
						<br /><br />
						Our contribution with this work is threefold. 
						We provide a new sphere quad partitioning algorithm.
						<br/>
						We propose a method to handle mesh connectivity using connection surfaces as a scaffold.
						<br />
						And our method provides a way to process the geometry with a full pipeline of discrete local steps. 
						That are not affected by global features such as cycles. And each step can be substituted easily by
						a different method so long as the step outputs a result compatible with the rest.<br />
						üñ±Ô∏è
					</aside>	
				</section>
				<section> 
					Advantages
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div>
						<ul style="font-size: 25px;">
							<li style="padding-top: 0px;">Minimal User Input</li>
							<li style="padding-top: 14px;">Highly Parallelizable Process</li>
							<li style="padding-top: 14px;">Hex Mesh Topologically Aligned with Boundary</li>
							<li style="padding-top: 14px;">Structured Mesh</li>
						</ul>
					</div>
					<aside class="notes">
						Our method features some interesting properties.
						It requires very little user input aside from optional minor changes. And the whole process
						of generation of the mesh and optimization can be done in interactive time.
						<br />
						The whole processing being composed of discrete steps applied locally means it is
						very easy to parallelize efficiently.
						<br />
						The geometry of the mesh is aligned with the boundary of the domain, which is desirable 
						for fluids simulation.
						<br />
						And finally, the mesh built is very structured and has clear characteristics that can be exploited
						in further modifications of the mesh. Such as skeleton aligned refinements.
						üñ±Ô∏è
					</aside>	
				</section>

				<section> 
					Future Work
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div>
						<ul style="font-size: 25px;">
							<li style="padding-top: 14px;">Local mesh adaptation <a href="http://pers.ge.imati.cnr.it/livesu/papers/LMPS16/LMPS16.pdf">(Livesu, CGF 2016)</a></li>
							<li style="padding-top: 14px;">Improve Sphere Partition</li>
							<li style="padding-top: 14px;">Further Optimization for Larger Meshes</li>
							<li style="padding-top: 14px;">Application to Gaseous Simulation in Lungs</li>
						</ul>
					</div>
					<aside class="notes">
						In spite of already promising results, a number of improvements can still be made to our method.
						For one, we are planning on exploring the topic of local mesh adaption that is mention by Livesu & al 
						in their original article on the topic.
						<br />
						<br />
						We also plan on improving further the sphere partitioning euristic. It currently provides workable results
						but could possibly be improved with more time. We are especially interested in finding out if there exists a 
						cannonical quad partition of a sphere that could be used.
						<br />
						<br />
						In the current state, our process could also be further optimized. The whole method being completely deterministic,
						it should be possible to improve memory management and parallel processing. Since our target applications
						are in fluid simulation, we will have to be able to produce very large meshes in the order of millions of hexes efficiently.
						<br/>
						<br />
						One current application that we are starting to work on in partnership with a team that does fluids simulation
						is to apply our method to the construction of dynamic meshes for gaseous simulation in lungs.
						üñ±Ô∏è
					</aside>
				</section>

				<section> 
					Acknowledgments
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-vstack">
						<div>
							<ul style="font-size: 25px;">
								<li>Thanks to <a hreflang="https://www.sciencedirect.com/science/article/abs/pii/S0010448518304238">(Bracci, CAD 2019)</a> for <a hreflang="https://www.hexalab.net/">Hexalab</a></li>
							</ul>
						</div>
						<div>
							<p style="font-size:15px; padding-top: 100px;">
								Slides use <a href="https://revealjs.com/">RevealJS</a>,
								<a href="https://threejs.org/">ThreeJS</a>, and 
								<a href="https://github.com/paulviville/CMapJS">CMapJS</a>.
							</p>
						</div>
					</div>
					<aside class="notes">
						Thank you for taking the time to listen to my presentation.
						I would like to give a special thanks to the team that created hexalab and centralized 
						articles and results for hexahedral meshing.
						<br /><br />
						I will know answer to questions.
						üñ±Ô∏è
					</aside>	
				</section>
				

				<section> 
					Appendix
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
				</section>

				<section id="Remeshing"> 
					Remeshing
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-vstack">  
						<div class="r-hstack">
							<img src="Images/Path_Co/path_u_0.png" height="170px">
							<img class="fragment" src="Images/Path_Co/path_u_1.png" height="170px">
							<img class="fragment" src="Images/Path_Co/path_u_2.png" height="170px">
						</div>
						<div class="r-hstack">
							<img class="fragment" src="Images/Path_Co/path_u_3.png" height="170px">
							<img class="fragment" src="Images/Path_Co/path_u_4.png" height="170px">
						</div>
					</div>
					<aside class="notes">
						<br /><br />
						üñ±Ô∏è
					</aside>
				</section>

				<section id="Remeshing"> 
					Remeshing
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-vstack">  
						<div class="r-hstack">
							<img src="Images/Path_Co/path_e_0.png" height="190px">
							<img class="fragment" src="Images/Path_Co/path_e_1.png" height="190px">
						</div>
						<div class="r-hstack">
							<img class="fragment" src="Images/Path_Co/path_e_2.png" height="190px">
							<img class="fragment" src="Images/Path_Co/path_e_3.png" height="190px">
						</div>
					</div>
					<aside class="notes">
						<br /><br />
						üñ±Ô∏è
					</aside>
				</section>

				<section id="Results"> 
					Results Comparisons
					<hr style="width: 70%; display:flex; justify-content:space-evenly;">
					<div class="r-vstack">  
						<img src="Images/Utils/results.PNG" height="340px">
					</div>
					<aside class="notes">
						<br /><br />
					</aside>
				</section>

			</div>
		</div>

		<script type="module">
			import Stats from './CMapJS/Dependencies/stats.module.js'
			import Reveal from './Reveal/reveal.esm.js'
			import Slide from './Slide.js'
			import Renderer from './CMapJS/Rendering/Renderer.js';
			import * as THREE from './CMapJS/Dependencies/three.module.js';
			import {OrbitControls} from './CMapJS/Dependencies/OrbitsControls.js';
			import {load_graph} from './CMapJS/IO/Graph_Formats/Graph_IO.js' 
			import {load_cmap2, export_cmap2} from './CMapJS/IO/Surface_Formats/CMap2_IO.js' 
			import {load_cmap3} from './CMapJS/IO/Volumes_Formats/CMap3_IO.js' 
			import {BoundingBox} from './CMapJS/Utils/BoundingBox.js';
			import {
				slide_overview,
				slide_sphere_partition,
				slide_partition_results,
				slide_flat_partition,
				slide_ortho_partition,
				slide_3_4_partition,
				slide_process_simple, 
				slide_process_0, 
				slide_process_1, 
				slide_process_2,
				slide_santa_comparison,
				slide_metatron_comparison,
				slide_fertility_result,
				slide_dinopet_result,
				slide_horse_result,
				slide_cycles_result,
				slide_edge_cases,
			} from './slides.js';

			import RevealNotes from './Reveal/notes/notes.esm.js'

			let slides = new Array();
			slides["Overview"] = slide_overview;
			slides["Sphere_Partition"] = slide_sphere_partition;
			slides["Results_Partition"] = slide_partition_results;
			slides["Flat_Partition"] = slide_flat_partition;
			slides["Ortho_Partition"] = slide_ortho_partition;
			slides["Pipeline_simple"] = slide_process_simple;
			slides["Pipeline_0"] = slide_process_0;
			slides["Pipeline_1"] = slide_process_1;
			slides["Pipeline_2"] = slide_process_2;
			slides["Comparisions_Santa"] = slide_santa_comparison;
			slides["Comparisions_Metatron"] = slide_metatron_comparison;
			slides["Results_Fertility"] = slide_fertility_result;
			slides["Results_Horse"] = slide_horse_result;
			slides["Results_Dinopet"] = slide_dinopet_result;
			slides["Results_Cycles"] = slide_cycles_result;
			slides["Limitations"] = slide_edge_cases;
			// slides["Ortho_Partition_3_4"] = slide_3_4_partition;
			
			let active_slide;
			Reveal.addEventListener('slidechanged', function(event) {
				if(active_slide) active_slide.close();
				var sectionID = Reveal.getCurrentSlide().id;
				active_slide = slides[sectionID]
				if(active_slide) active_slide.open();
			});


			let fragment_events = [];
			Reveal.addEventListener('fragmentshown', function(event) {
				if(fragment_events[event.fragment.id])
					fragment_events[event.fragment.id]();
			});
			Reveal.addEventListener('fragmenthidden', function(event) {
				if(fragment_events[event.fragment.id])
					fragment_events[event.fragment.id]();
			});

			Reveal.initialize({
				touch: false, 
				slideNumber: 'c/t',
				transition: 'none',
				showNotes: true,

				plugins: [RevealNotes]
			}).then(() => {
				slides["Overview"].init(
					document.getElementById("overview_input"),
				 	document.getElementById("overview_output")
				);
				fragment_events["Overview_clipping"] = 
					slides["Overview"].toggle_clipping.bind(slides["Overview"]);
				fragment_events["Overview_pause"] = 
					slides["Overview"].pause.bind(slides["Overview"]);

				slides["Sphere_Partition"].init(
					document.getElementById("SP_init"),
					document.getElementById("SP_Points"),
					document.getElementById("SP_Raw"),
					document.getElementById("SP_Remesh"),
					document.getElementById("SP_Dual"),
					document.getElementById("SP_Result")
				);

				slides["Results_Partition"].init(
					document.getElementById("Partition14"),
					document.getElementById("Partition_failure")
				);

				slides["Flat_Partition"].init(
					document.getElementById("FP_3Points"),
					document.getElementById("FP_4Points"),
					document.getElementById("FP_5Points")
				);
				fragment_events["Flat_sphere"] = 
					slides["Flat_Partition"].toggle_spheres.bind(slides["Flat_Partition"]);
				fragment_events["Flat_surface"] = 
					slides["Flat_Partition"].toggle_surfaces.bind(slides["Flat_Partition"]);
				fragment_events["Flat_base"] = 
					slides["Flat_Partition"].toggle_base.bind(slides["Flat_Partition"]);

				slides["Ortho_Partition"].init(
					document.getElementById("OP_3Points"),
					document.getElementById("OP_4Points"),
					document.getElementById("OP_5Points")
				);
				fragment_events["Ortho_base"] = 
					slides["Ortho_Partition"].toggle_base.bind(slides["Ortho_Partition"]);
				fragment_events["Ortho_surface"] = 
					slides["Ortho_Partition"].toggle_surfaces.bind(slides["Ortho_Partition"]);

				// slides["Ortho_Partition_3_4"].init(
				// 	document.getElementById("Ortho3_1"),
				// 	document.getElementById("Ortho3_2"),
				// 	document.getElementById("Ortho4_1"),
				// 	document.getElementById("Ortho4_2")
				// );

				slides["Pipeline_0"].init(
					document.getElementById("Pipeline0_surface"),
				 	document.getElementById("Pipeline0_skel"),
					document.getElementById("Pipeline0_skel_simple")
				);


				slides["Pipeline_simple"].init(
					document.getElementById("Pipeline00_surface"),
				 	document.getElementById("Pipeline00_skel"),
					document.getElementById("Pipeline00_scaffold"),
					document.getElementById("Pipeline00_mesh")
				);

				slides["Pipeline_1"].init(
					document.getElementById("Pipeline1_scaffold"),
					document.getElementById("Pipeline1_initial_mesh"),
					document.getElementById("Pipeline1_surface_fit_mesh")
				);

				slides["Pipeline_2"].init(
					document.getElementById("Pipeline2_padding"),
					document.getElementById("Pipeline2_result"),
					document.getElementById("Pipeline2_quality")
				);
				fragment_events["Pipeline2_material"] = 
					slides["Pipeline_2"].toggle_material.bind(slides["Pipeline_2"]);
				fragment_events["Pipeline2_rotate"] = 
					slides["Pipeline_2"].toggle_rotate.bind(slides["Pipeline_2"]);
				fragment_events["Pipeline2_rotate2"] = 
					slides["Pipeline_2"].toggle_rotate.bind(slides["Pipeline_2"]);

				slides["Comparisions_Santa"].init(
				document.getElementById("Santa_live"),
				document.getElementById("Santa_ours"),
				);
				fragment_events["Santa_clipping"] = 
					slides["Comparisions_Santa"].toggle_clipping.bind(slides["Comparisions_Santa"]);
			
				slides["Comparisions_Metatron"].init(
					document.getElementById("Meta_live"),
					document.getElementById("Meta_ours"),
				);
				fragment_events["Metatron_clipping"] = 
					slides["Comparisions_Metatron"].toggle_clipping.bind(slides["Comparisions_Metatron"]);
			
				slides["Results_Fertility"].init(
					document.getElementById("Result_Fertility")
				);
				fragment_events["Results_Fertility_material"] = 
					slides["Results_Fertility"].toggle_material.bind(slides["Results_Fertility"]);
				fragment_events["Results_Fertility_Clipping"] = 
					slides["Results_Fertility"].toggle_clipping.bind(slides["Results_Fertility"]);
			
				slides["Results_Dinopet"].init(
					document.getElementById("Result_Dinopet")
				);
				fragment_events["Results_Dinopet_material"] = 
					slides["Results_Dinopet"].toggle_material.bind(slides["Results_Dinopet"]);
				fragment_events["Results_Dinopet_Clipping"] = 
					slides["Results_Dinopet"].toggle_clipping.bind(slides["Results_Dinopet"]);
			
				slides["Results_Horse"].init(
					document.getElementById("Result_Horse")
				);
				fragment_events["Results_Horse_material"] = 
					slides["Results_Horse"].toggle_material.bind(slides["Results_Horse"]);
				fragment_events["Results_Horse_Clipping"] = 
					slides["Results_Horse"].toggle_clipping.bind(slides["Results_Horse"]);
			
				slides["Results_Cycles"].init(
					document.getElementById("Result_Cycles")
				);
				fragment_events["Results_Cycles_material"] = 
					slides["Results_Cycles"].toggle_material.bind(slides["Results_Cycles"]);
				fragment_events["Results_Cycles_Clipping"] = 
					slides["Results_Cycles"].toggle_clipping.bind(slides["Results_Cycles"]);
			

				slides["Limitations"].init(
					document.getElementById("Edge_rocker"),
					document.getElementById("Edge_mech"),
				);
				fragment_events["Edge_rocker_skel"] = 
					slides["Limitations"].toggle_rocker_skel.bind(slides["Limitations"]);
				fragment_events["Edge_rocker_vol"] = 
					slides["Limitations"].toggle_rocker_vol.bind(slides["Limitations"]);
				fragment_events["Edge_rocker_vol_clip"] = 
					slides["Limitations"].toggle_rocker_vol_clip.bind(slides["Limitations"]);
			
				fragment_events["Edge_mech_skel"] = 
					slides["Limitations"].toggle_mech_skel.bind(slides["Limitations"]);
				fragment_events["Edge_mech_vol"] = 
					slides["Limitations"].toggle_mech_vol.bind(slides["Limitations"]);
				fragment_events["Edge_mech_vol_clip"] = 
					slides["Limitations"].toggle_mech_vol_clip.bind(slides["Limitations"]);
			
			});
			
			
		</script>
	</body>

</html>